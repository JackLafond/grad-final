<!DOCTYPE html>
<!-- original code from Jane Wong on bl.ocks -->

<html lang="en">
    <meta charset="utf-8" />

    <head>
        <meta charset="utf-8">
        <title>PCP Test</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>

    <link href="styles/styles.css" rel="stylesheet" type="text/css">

    <style>

        h3 {
            margin-top: 100px;
        }

        p {
            margin-top: 30px;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .axis {
          opacity: 0.4;
        }
        
        .axis:hover {
          opacity: 1;
        }

        #content-weighted-lines {
            display: flex;
            flex-direction: row;
        }

        .sliders {
            display: flex;
            flex-direction: column;
        }

        .sliders label {
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .sliders input {
            margin-top: 20px;
        }

        body {
            display: flex;
            flex-direction: column;
            margin-left: 10%;
            margin-right: 10%;
        }

    </style>

    <body>

        <nav tabindex="0">
            <div class="menu_dropdown">
            <p><a href="index.html">Home</a></p>
            <p><a href="test2.html">Final Visualization</a></p>
            <p><a href="ProcessBook.html">Process Book</a></p>
            <p><a href="Presentation.html">Presentation</a></p>
            <p><a href="recreateWash.html">Washington Post</a></p>
            <p><a href="hive.html">Hive</a></p>
            <p class="thislink">PCP</p>
            </div>
        </nav>

        <div id="content-small-multiples">
            <h3>Small Multiples</h3>
            <div id="svg-small-multiples"></div>
            <p>In looking at these small multiples it is important to consider the sample sizes of these accolades. For example awards like the MVP are only given to one player each year, and are mostly a QB biased position in the current landscape of the NFL. It is also important to consider that these aggregations are only for players who were drafted between 2010 and 2020, so players like Tom Brady and Aaron Rodgers are not inlcuded. As a result some of these less frequent and position specific awards are not the best for comparisons. Instead we should focus primarily on the follwoing three awards; Firt Team All Pro, Second Team All Pro, and Pro Bowl. For First and Second Team All Pro a player at each position is picked, making it a much more frequent award and non position biased. The Pro Bowl is an NFL run game at the end of the season which invites the game's all-stars based on player, coach, and fan voting. Like the All Pro awards the Pro Bowl invites players of all positions, and if a player declines to join like in the case that they are playing in the Super Bowl, then replacements are found making this another good award to represent general success across the NFL.</p>
            <p>Considering these three accolades, it is clear that the SEC dominates all other college conferences as their drafted players from 2010-2020 have accumulated the most First and Second Team All Pro, and Pro Bowl awards, doubling most other conferences except for the "Other" grouping. Has this always been the trend though? In the next section we dive into the accolades by year to see the time trends of college conferences and their players' accolades.</p>
        </div>
        <div id="content-small-lines">
            <h3>Accolades Over Time</h3>
            <div id="svg-small-lines"></div>
            <p>These line charts show the total accolades for NFL draftees colored by college conferences, and charted over draft years. Since the Y valeus for each year represent the total accolades for that college conference's draft class for that specific year we should expect to see a generally decreasing trend for all the lines as players drafted in more recent years like 2020 have had less time to accumulate awards when compared to players drafted in earlier years who have had more time in the NFL.</p>
            <p>In the First Team All Pro chart there is no clear winner and each conference generally deacreased from 2010 to 2020. However, in the Second Team All Pro and Pro Bowl Charts is where the SEC starts to shine, as in both charts the SEC consitently charts more accoaldes than all other college conferences except for some occasional spikes. Anohter important note is that in each of these charts the SEC decreaseed less than most other college conferences, and in the case of Second Team All Pro, they were close to a horizontal trend. These two findings suggest that the SEC produces more NFL ready players each year than otehr conferences, and the smaller decrease suggests that in more recent years their players have actually become more NFL ready than in the past as their accolade scores are not decreasing as mmuch as other conferences.</p>
        </div>
        <div id="content-weighted-lines">
            <div class="sliders">
                <input type="range" id="First_AP" min="0" max="4" value="3"><label for="First_AP">1st Team AP</label>
                <input type="range" id="Second_AP" min="0" max="4" value="2"><label for="Second_AP">2nd Team AP</label>
                <input type="range" id="Pro_Bowl" min="0" max="4" value="1"><label for="Pro_Bowl">Pro Bowl</label>
                <button class="update" type="button" onclick="makeWeightedLines()">Update Chart</button>
            </div>
            <div id="svg-weighted-lines"></div>
            <p>Included here is a combined weighted score chart that aggregates each of the three awards based on their weights. The default weighting is 3, 2, and 1 for First Team All Pro, Second Team All Pro and Pro Bowl, however you can change these weights as you see fit, each scale ranges from 0 to 4.</p>
        </div>
        <div id="content-sec-bubble">
            <h3>SEC Accolade Bubble Chart</h3>
            <p>From the previous charts it is clear that the SEC dominates other conferences in terms of producing NFL ready players, but what positions is it best at producing? Since First and Second Team All Pro, and Pro Bowl awards go to every position it is hard to see where on the field the SEC schools perform the bast. The following visualization shows a hierarvhy bubble charts that displays the accolades by position. The area of each circle is encoded by the total number of accolades for the circle allowing for comparisons within and across positions.</p>
            <div id="svg-sec-bubble"></div>
            <p>Suprisingly, the SEC does not produce nearly as many good QBs as it does for other positions. Another interesting finding is that for most positions, they have more Pro Bowls than Second Team All Pros and more Second Team All Pros than First Team All Pros. This is generally expected as First Team All Pro is the highest accolade among these three awards, However for Cornerback and Safety, these positions saw more First Team All Pros than double their Second Team All Pros. This suggests that the SEC is not just producing very good Cornerbacks and Safeties, but they are producing some of the leagues most elite defensive skill position players.</p>
        </div>

    </body>
    <script src="https://d3js.org/d3-array.v2.min.js"></script>
    <!-- <script src="https://d3js.org/d3.v7.min.js"></script> -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <script>

        function makePosPCP() {

            // Set the dimensions and margins of the graph
            const margin = { top: 30, right: 50, bottom: 10, left: 50 },
                width = 1200 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;
        
            // Append the svg object to the body of the page
            const svg = d3.select("#svg-container1")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
        

            // Parse and load the data
            d3.csv("python/results/total/joindf_total.csv", function(data) {

                data.forEach(d => {
                    if(d.Pos == 'OLB' || d.Pos == 'ILB') {
                        d.Pos = 'LB';
                    } else if (d.Pos == 'SS' || d.Pos == 'FS') {
                        d.Pos = 'S';
                    } else if (d.Pos == 'OT' || d.Pos == 'OG' || d.Pos == 'G' || d.Pos == 'NT' || d.Pos == 'C') {
                        d.Pos = 'OL';
                    }
                });

                data = data.filter(d => { return (d.Pos != 'LS' && d.Pos != 'P');});

                let positions = [...new Set(data.map(d => d.Pos))];

                var color = d3.scaleOrdinal().domain(positions).range(d3.schemeSet3);

                // Extract the list of dimensions and create a scale for each
                const dimensions = ["MVP", "SB_MVP", "SB_WIN", "OPOY", "DPOY", "OROY", "DROY", "First_AP", "Second_AP", "Pro_Bowl"];
                // For each dimension, I build a linear scale. I store all in a y object
                var y = {}
                for (i in dimensions) {
                    name = dimensions[i]
                    y[name] = d3.scaleLinear()
                        .domain( d3.extent(data, function(d) { return +d[name]; }) )
                        .range([height, 0])
                }
        
                // Build the X scale -> it finds the best position for each Y axis
                const x = d3.scalePoint()
                    .range([0, width])
                    .padding(1)
                    .domain(dimensions);
        
                // Highlight the specie that is hovered
                var highlight = function(d){

                    let selected_pos;

                    if(d.Pos) {
                        selected_pos = d.Pos;
                    } else {
                        selected_pos = d;
                    }

                    // first every group turns grey
                    d3.selectAll(".line")
                        .transition().duration(200)
                        .style("stroke", "lightgrey")
                        .style("opacity", "0")
                    // Second the hovered specie takes its color
                    d3.selectAll("." + selected_pos)
                        .transition().duration(200)
                        .style("stroke", color(selected_pos))
                        .style("opacity", "1")
                }

                // Unhighlight
                var doNotHighlight = function(d){
                    d3.selectAll(".line")
                        .transition().duration(200).delay(1000)
                        .style("stroke", function(d){ return( color(d.Pos))} )
                        .style("opacity", ".2")
                }
        
                // The path function take a row of the csv as input, and return x and y coordinates of the line to draw for this raw.
                function path(d) {
                    return d3.line()(dimensions.map(function(p) { 
                        return [x(p), y[p](d[p])]; 
                    }));
                }

                // Draw the lines
                svg
                    .selectAll("myPath")
                    .data(data)
                    .enter()
                    .append("path")
                    .attr("class", function (d) { return "line " + d.Pos } ) // 2 class for each line: 'line' and the group name
                    .attr("d",  path)
                    .style("fill", "none" )
                    .style("stroke", function(d){ return( color(d.Pos))} )
                    .style("opacity", 0.2)
                    .style("stroke-width", 2)
                    .on("mouseover", highlight)
                    .on("mouseleave", doNotHighlight );

                // Draw the axis:
                svg.selectAll("myAxis")
                    // For each dimension of the dataset I add a 'g' element:
                    .data(dimensions).enter()
                    .append("g")
                    .attr("class", "axis")
                    // I translate this element to its right position on the x axis
                    .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
                    // And I build the axis with the call function
                    .each(function(d) { d3.select(this).call(d3.axisLeft().ticks(y[d].domain()[1]).scale(y[d])); })
                    // Add axis title
                    .append("text")
                    .style("text-anchor", "middle")
                    .attr("y", -9)
                    .text(function(d) { return d; })
                    .style("fill", "black")
                    .style("font-size", "12px")
                    .style("font-family", "Helvetica")


                // make legend 
                svg.selectAll('.legend-circle')
                    .data(positions)
                    .enter()
                        .append('circle')
                        .attr("class", 'legend-circle')
                        .attr('Pos', function (d) {
                            return d;
                        })
                        .attr('r', 5)
                        .attr('cx', width)
                        .attr('cy', function (d, i) {
                            return 10 + (20 * i);
                        })
                        .style('fill', function (d) {
                            return color(d);
                        })
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight );

                svg.selectAll('.legend-text')
                    .data(positions)
                    .enter()
                        .append("text")
                        .attr('class', 'legend-text')
                        .attr('Pos', function (d) {
                            return d;
                        })
                        .attr("x", width + 20)
                        .attr("y", function (d, i) {
                            return 10 + (20 * i);
                        })
                        .text(function (d) {
                            return d;
                        })
                        .style("font-size", "12px")
                        .style("font-family", "Helvetica")
                        .attr("alignment-baseline","middle")
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight );
            });
        }

        function makeConfPCP() {

            // Set the dimensions and margins of the graph
            const margin = { top: 30, right: 50, bottom: 10, left: 50 },
                width = 1200 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;
        
            // Append the svg object to the body of the page
            const svg = d3.select("#svg-container2")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
        

            // Parse and load the data
            d3.csv("python/results/total/joindf_total.csv", function(data) {

                data.forEach(d => {
                    if(d.Pos == 'OLB' || d.Pos == 'ILB') {
                        d.Pos = 'LB';
                    } else if (d.Pos == 'SS' || d.Pos == 'FS') {
                        d.Pos = 'S';
                    } else if (d.Pos == 'OT' || d.Pos == 'OG' || d.Pos == 'G' || d.Pos == 'NT' || d.Pos == 'C') {
                        d.Pos = 'OL';
                    }

                    if(d.Conf_Clean == 'Big Ten') {
                        d.Conf_Clean = 'Big_Ten';
                    } else if(d.Conf_Clean == 'Big 12') {
                        d.Conf_Clean = 'Big_12';
                    }
                })

                data = data.filter(d => { return (d.Pos != 'LS' && d.Pos != 'P');});

                let confs = [...new Set(data.map(d => d.Conf_Clean))];

                var color = d3.scaleOrdinal().domain(confs).range(d3.schemeSet1);

                // Extract the list of dimensions and create a scale for each
                const dimensions = ["MVP", "SB_MVP", "SB_WIN", "OPOY", "DPOY", "OROY", "DROY", "First_AP", "Second_AP", "Pro_Bowl"];
                // For each dimension, I build a linear scale. I store all in a y object
                var y = {}
                for (i in dimensions) {
                    name = dimensions[i]
                    y[name] = d3.scaleLinear()
                        .domain( d3.extent(data, function(d) { return +d[name]; }) )
                        .range([height, 0])
                }
        
                // Build the X scale -> it finds the best position for each Y axis
                const x = d3.scalePoint()
                    .range([0, width])
                    .padding(1)
                    .domain(dimensions);
        
                // Highlight the specie that is hovered
                var highlight = function(d){

                    let selected_conf;

                    if(d.Conf_Clean) {
                        selected_conf = d.Conf_Clean;
                    } else {
                        selected_conf = d;
                    }

                    // first every group turns grey
                    d3.selectAll(".line")
                        .transition().duration(200)
                        .style("stroke", "lightgrey")
                        .style("opacity", "0")
                    // Second the hovered specie takes its color
                    d3.selectAll("." + selected_conf)
                        .transition().duration(200)
                        .style("stroke", color(selected_conf))
                        .style("opacity", "1")
                }

                // Unhighlight
                var doNotHighlight = function(d){
                    d3.selectAll(".line")
                        .transition().duration(200).delay(1000)
                        .style("stroke", function(d){ return( color(d.Conf_Clean))} )
                        .style("opacity", ".2")
                }
        
                // The path function take a row of the csv as input, and return x and y coordinates of the line to draw for this raw.
                function path(d) {
                    return d3.line()(dimensions.map(function(p) { 
                        return [x(p), y[p](d[p])]; 
                    }));
                }

                // Draw the lines
                svg
                    .selectAll("myPath")
                    .data(data)
                    .enter()
                    .append("path")
                    .attr("class", function (d) { return "line " + d.Conf_Clean } ) // 2 class for each line: 'line' and the group name
                    .attr("d",  path)
                    .style("fill", "none" )
                    .style("stroke", function(d){ return( color(d.Conf_Clean))} )
                    .style("opacity", 0.2)
                    .style("stroke-width", 2)
                    .on("mouseover", highlight)
                    .on("mouseleave", doNotHighlight );

                // Draw the axis:
                svg.selectAll("myAxis")
                    // For each dimension of the dataset I add a 'g' element:
                    .data(dimensions).enter()
                    .append("g")
                    .attr("class", "axis")
                    // I translate this element to its right position on the x axis
                    .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
                    // And I build the axis with the call function
                    .each(function(d) { d3.select(this).call(d3.axisLeft().ticks(y[d].domain()[1]).scale(y[d])); })
                    // Add axis title
                    .append("text")
                    .style("text-anchor", "middle")
                    .attr("y", -9)
                    .text(function(d) { return d; })
                    .style("fill", "black")
                    .style("font-size", "12px")
                    .style("font-family", "Helvetica")


                // make legend 
                svg.selectAll('.legend-circle')
                    .data(confs)
                    .enter()
                        .append('circle')
                        .attr("class", 'legend-circle')
                        .attr('Pos', function (d) {
                            return d;
                        })
                        .attr('r', 5)
                        .attr('cx', width)
                        .attr('cy', function (d, i) {
                            return 10 + (20 * i);
                        })
                        .style('fill', function (d) {
                            return color(d);
                        })
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight );

                svg.selectAll('.legend-text')
                    .data(confs)
                    .enter()
                        .append("text")
                        .attr('class', 'legend-text')
                        .attr('Pos', function (d) {
                            return d;
                        })
                        .attr("x", width + 20)
                        .attr("y", function (d, i) {
                            return 10 + (20 * i);
                        })
                        .text(function (d) {
                            return d;
                        })
                        .style("font-size", "12px")
                        .style("font-family", "Helvetica")
                        .attr("alignment-baseline","middle")
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight );
            });

        }

        function makeConfBars() {

            // Set the dimensions and margins of the graph
            const margin = { top: 30, right: 50, bottom: 10, left: 50 },
                width = 1200 - margin.left - margin.right,
                height = 500 - margin.top - margin.bottom;

            d3.csv("python/results/total/college_conf_bars_total.csv", function(data) {

                let confs = ['ACC', 'Big 12', 'Big Ten', 'Other', 'Pac12', 'SEC']

                // List of subgroups = header of the csv files = soil condition here
                var subgroups = data.columns.slice(1);

                // List of groups = species here = value of the first column called group -> I show them on the X axis
                var groups = d3.map(data, function(d){return(d.accolades)}).keys();

                var svg = d3.select("#svg-container3")
                    .append("svg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                        .attr("transform",
                            "translate(" + margin.left + "," + margin.top + ")");

                // Add X axis
                var x = d3.scaleBand()
                    .domain(groups)
                    .range([0, width])
                    .padding([0.2]);

                svg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x).tickSizeInner(0));

                // Add Y axis
                var y = d3.scaleLinear()
                    .domain([0, 300])
                    .range([ height, 0 ]);

                svg.append("g")
                    .call(d3.axisLeft(y));

                // Another scale for subgroup position?
                var xSubgroup = d3.scaleBand()
                    .domain(subgroups)
                    .range([0, x.bandwidth()])
                    .padding([0.05]);

                // color palette = one color per subgroup
                var color = d3.scaleOrdinal()
                    .domain(confs)
                    .range(['#013ca6', '#ef483e', '#0088CE', '#808080', '#04223f', '#ffd046']);

                // Show the bars
                svg.append("g")
                    .selectAll("g")
                    // Enter in data = loop group per group
                    .data(data)
                    .enter()
                    .append("g")
                        .attr("transform", function(d) { return "translate(" + x(d.accolades) + ",0)"; })
                        .selectAll("rect")
                        .data(function(d) { return subgroups.map(function(key) { return {key: key, value: d[key]}; }); })
                        .enter().append("rect")
                            .attr("x", function(d) { return xSubgroup(d.key); })
                            .attr("y", function(d) { return y(d.value); })
                            .attr("width", xSubgroup.bandwidth())
                            .attr("height", function(d) { return height - y(d.value); })
                            .attr("fill", function(d) { return color(d.key); });

            });
        }

        function makeSmallMultiples() {

            let title_map = {
                'MVP': 'MVP',
                'SB_MVP': 'Super Bowl MVP',
                'SB_WIN': 'Super Bowl Win',
                'OPOY': 'OPOY',
                'OROY': 'OROY',
                'DPOY': 'DROY',
                'DROY': 'DROY',
                'Pro_Bowl': 'Pro Bowl',
                'First_AP': 'First Team All Pro',
                'Second_AP': 'Second Team All Pro'
            }

            // Set the dimensions and margins of the graph
            const margin = { top: 40, right: 5, bottom: 10, left: 5 },
                width = 250 - margin.left - margin.right,
                height = 160 - margin.top - margin.bottom;

            d3.csv("python/results/total/college_conf_bars_total.csv", function(data) {

                // Highlight the specie that is hovered
                var highlight = function(d){

                    let conf = d.conf;
                    if(conf == 'Big Ten') {
                        conf = 'Big_Ten';
                    } else if (conf == 'Big 12') {
                        conf = 'Big_12';
                    }

                    // first every group turns grey
                    d3.selectAll(".bar")
                        .transition().duration(200)
                        .attr("opacity", ".05");
                    // Second the hovered specie takes its color
                    d3.selectAll(".bar." + conf)
                        .transition().duration(200)
                        .attr("opacity", "1");
                        // .attr("stroke", "black")
                        // .attr("stroke-width", "2px");
                }

                // Unhighlight
                var doNotHighlight = function() {
                    d3.selectAll(".bar")
                        .transition().duration(200)
                        .attr("opacity", "1");
                        // .attr("stroke", "none");
                }

                let confs = ['ACC', 'Big 12', 'Big Ten', 'Other', 'Pac12', 'SEC'];

                // List of subgroups = header of the csv files = soil condition here
                var subgroups = data.columns.slice(1);

                // List of groups = species here = value of the first column called group -> I show them on the X axis
                var groups = d3.map(data, function(d){return(d.accolades)}).keys();

                // group the data
                data.forEach((d) => {
                    d.Values = [{val: d['ACC'], conf: 'ACC', color: '#013ca6'}, {val: d['Big 12'], conf: 'Big 12', color: '#ef483e'}, {val: d['Big Ten'], conf: 'Big Ten', color: '#0088CE'}, {val: d['Other'], conf: 'Other', color: '#808080'}, {val: d['Pac12'], conf: 'Pac12', color: '#04223f'}, {val: d['SEC'], conf: 'SEC', color: '#ffd046'}];
                });

                // Add X axis
                var xScale = d3.scaleBand()
                    .domain(confs)
                    .range([0, width])
                    .padding([0.2]);

                var yScale = d3.scaleLinear()
                    .range([height, margin.top]);

                var xAxis = d3.axisBottom()
                    .scale(xScale)
                    .tickSize(0)
                    .tickPadding([10]);

                // create a separate SVG object for each group
                // class each SVG with parameter from metrics
                var svg = d3.select('#svg-small-multiples').selectAll('svg')
                    .data(data)
                    .enter()
                        .append('svg')
                        .attr("class", function(d) {return d.accolades;});

                // loop over the data and create the bars
                data.forEach(function(d) {
                    //console.log(d);
                    //console.log(metrics);
                    // reset yScale domain based on the set of the_value's for these metrics

                    yScale.domain([0, d3.max(d.Values.map((d) => {
                        return parseInt(d.val);
                    }))]);

                    // select the right svg for this set of metrics
                    d3.select("svg." + d.accolades)
                        .selectAll('.bar')
                        .data(d.Values) // use d.value to get to the the_value
                        .enter()
                            .append('rect')
                            .attr('class', (c) => {
                                if(c.conf == 'Big Ten') {
                                    return 'bar Big_Ten';
                                } else if(c.conf == 'Big 12') {
                                    return 'bar Big_12';
                                } else {
                                    return 'bar ' + c.conf;
                                }
                            })
                            .attr('x', function(c) { return xScale(c.conf); })
                            .attr('width', xScale.bandwidth())
                            .attr('y', function(c) { return yScale(c.val); })
                            .attr('height', function(c) { return height - yScale(c.val); })
                            .attr('fill', function(c) { return c.color; })
                            .on("mouseover", highlight)
                            .on("mouseleave", doNotHighlight);
                            
                    d3.select("svg." + d.accolades)
                        .selectAll(".bar-label")
                        .data(d.Values)
                        .enter()
                            .append('text')
                            .attr('class', 'bar-label')
                            .attr('x', function(c) { return xScale(c.conf) + (xScale.bandwidth() / 2); })
                            .attr('y', function(c) { return yScale(c.val) - 5; })
                            .attr('stroke', 'none')
                            .attr('text-anchor', 'middle')
                            .attr('fill', 'black')
                            .style("font-family", "helvetica")
                            .style("font-size", "9px")
                            .text(function(c) { 
                                if(c.val == yScale.domain()[1]) {
                                    return c.val;
                                } 
                            });

                    d3.select("svg." + d.accolades)
                        .append("text")
                        .attr("x", width/2)
                        .attr("y", 0 + (margin.top / 2))
                        .attr("text-anchor", "middle")
                        .style("font-family", "helvetica")
                        .style("font-size", "12px")
                        .text(title_map[d.accolades]);

                    // call axis just on this SVG
                    // otherwise calling it 5 times for 5 metrics...
                    d3.select("svg." + d.accolades)
                        .append('g')
                        .attr('transform', 'translate(0,' + height + ')')
                        .call(xAxis);
                });  
            });
        }

        function makeLines() {

            // Highlight the specie that is hovered
            var highlight = function(d){

                let conf;

                if(d.values) {
                    conf = d.values[0].Conf_Clean;
                } else {
                    conf = d.conf;
                }

                if(conf == 'Big Ten') {
                    conf = 'Big_Ten';
                } else if(conf == 'Big 12') {
                    conf = 'Big_12';
                }

                // first every group turns grey
                d3.selectAll("path.change")
                    .transition().duration(200)
                    .attr("opacity", ".05");

                d3.selectAll("circle.change")
                    .transition().duration(200)
                    .attr("opacity", ".05");

                // Second the hovered specie takes its color
                d3.selectAll("path." + conf)
                    .transition().duration(200)
                    .attr("opacity", "1");
                    // .attr("stroke", "black")
                    // .attr("stroke-width", "2px");
                d3.selectAll("circle." + conf)
                    .transition().duration(200)
                    .attr("opacity", "1");

            }

            // Unhighlight
            var doNotHighlight = function() {
                d3.selectAll("path")
                    .transition().duration(200)
                    .attr("opacity", "1");
                    // .attr("stroke", "none");
                d3.selectAll("circle")
                    .transition().duration(200)
                    .attr("opacity", "1");
            }

            let title_map = {
                'MVP': 'MVP',
                'SB_MVP': 'Super Bowl MVP',
                'SB_WIN': 'Super Bowl Win',
                'OPOY': 'OPOY',
                'OROY': 'OROY',
                'DPOY': 'DROY',
                'DROY': 'DROY',
                'Pro_Bowl': 'Pro Bowl',
                'First_AP': 'First Team All Pro',
                'Second_AP': 'Second Team All Pro'
            }

            // Set the dimensions and margins of the graph
            const margin = { top: 40, right: 40, bottom: 40, left: 40 },
                width = 400 - margin.left - margin.right,
                height = 200 - margin.top - margin.bottom;

            let accolades = ['First_AP', 'Second_AP', 'Pro_Bowl'];

            d3.csv("python/results/total/college_year_lines.csv", function(data) {

                let confs = [
                    {conf: 'ACC', color: '#013ca6'}, 
                    {conf: 'Big 12', color: '#ef483e'}, 
                    {conf: 'Big Ten', color: '#0088CE'},
                    {conf: 'SEC', color: '#ffd046'},
                    {conf: 'Pac12', color: '#04223f'},
                    {conf: 'Other', color: '#808080'}];

                data.forEach((d) =>{
                    if(d.Conf_Clean == 'ACC') {
                        d.color = '#013ca6';
                    } else if (d.Conf_Clean == 'Big 12') {
                        d.color = '#ef483e'
                    } else if (d.Conf_Clean == 'Big Ten') {
                        d.color = '#0088CE';
                    } else if (d.Conf_Clean == 'Other') {
                        d.color = '#808080';
                    } else if (d.Conf_Clean == 'Pac12') {
                        d.color = '#04223f';
                    } else if (d.Conf_Clean == 'SEC') {
                        d.color = '#ffd046';
                    }
                });

                // Add X axis
                var x = d3.scaleTime()
                    .domain([new Date('2010'), new Date('2020/01')])
                    .range([0, width]);

                var y = d3.scaleLinear()
                    .range([height, 0]);


                // create a separate SVG object for each group
                // class each SVG with parameter from metrics
                var svg = d3.select('#svg-small-lines').selectAll('svg')
                    .data(accolades)
                    .enter()
                        .append('svg')
                            .attr("class", function(d) {return d + "_lines";})
                            .attr("width", width + margin.left + margin.right)
                            .attr("height", height + margin.top + margin.bottom);

                var groups = d3.nest()
                    .key(function(d) {return d.Conf_Clean;})
                    .entries(data);

                accolades.forEach((a) => {

                    y.domain([0, d3.max(data.map((d) => {
                        return parseInt(d[a]);
                    }))]);

                    cursvg = d3.select("svg." + a + "_lines")
                        .append("g")
                            .attr("transform",
                                "translate(" + margin.left + "," + margin.top + ")");

                    cursvg.selectAll(".line")
                        .data(groups)
                        .enter()
                            .append("path")
                            .attr('class', (d) => {
                                if(d.values[0].Conf_Clean == 'Big Ten') {
                                    return 'change Big_Ten';
                                } else if(d.values[0].Conf_Clean == 'Big 12') {
                                    return 'change Big_12';
                                } else {
                                    return 'change ' + d.values[0].Conf_Clean;
                                }
                            })
                            .attr("fill", "none")
                            .attr("stroke", function(d){ return d.values[0].color })
                            .attr("stroke-width", 1.5)
                            .attr("d", function(d){
                                return d3.line()
                                    .x(function(d) { 
                                        return x(new Date(d.Year)); })
                                    .y(function(d) { return y(+d[a]); })
                                    (d.values)
                            });

                    cursvg.append("g")
                        .attr("transform", "translate(0," + height + ")")
                        .call(d3.axisBottom(x).ticks(5).tickSize(0).tickPadding(15));

                    cursvg.append("g")
                        .call(d3.axisLeft(y).ticks(4).tickSize(0).tickPadding(15).tickFormat(d3.format("d")));

                    cursvg.append("text")
                        .attr("x", width/2)
                        .attr("y", -5)
                        .attr("text-anchor", "middle")
                        .style("font-family", "helvetica")
                        .style("font-size", "12px")
                        .text(title_map[a]);

                });

                let lastsvg = d3.select("svg." + accolades[accolades.length - 1] + "_lines");

                lastsvg.attr("width", width + margin.left + margin.right + 100)

                // make legend 
                lastsvg.selectAll('.legend-circle')
                    .data(confs)
                    .enter()
                        .append('circle')
                        .attr("class", (d) => {
                            if(d.conf == 'Big Ten') {
                                return 'legend-circle change Big_Ten';
                            } else if(d.conf == 'Big 12') {
                                return 'legend-circle change Big_12';
                            } else {
                                return 'legend-circle change ' + d.conf;
                            }
                        })
                        .attr('r', 5)
                        .attr('cx', width + margin.right + 20)
                        .attr('cy', function (d, i) {
                            return 20 + (20 * i);
                        })
                        .style('fill', function (d) {
                            return d.color;
                        })
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight);

                lastsvg.selectAll('.legend-text')
                    .data(confs)
                    .enter()
                        .append("text")
                        .attr('class', 'legend-text')
                        .attr("x", width + margin.right + 40)
                        .attr("y", function (d, i) {
                            return 20 + (20 * i);
                        })
                        .text(function (d) {
                            return d.conf;
                        })
                        .style("font-size", "16px")
                        .style("font-family", "Helvetica")
                        .attr("alignment-baseline","middle")
                        .attr('fill', 'black')
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight);
            });


        }

        function makeWeightedLines() {

            d3.select("#svg-weighted-lines").selectAll("*").remove();
            // Set the dimensions and margins of the graph
            const margin = { top: 40, right: 150, bottom: 40, left: 40 },
                width = 800 - margin.left - margin.right,
                height = 250 - margin.top - margin.bottom;

            d3.csv("python/results/total/college_year_lines.csv", function(data) {

                // Highlight the specie that is hovered
                var highlight = function(d){

                    let conf;

                    if(d.values) {
                        conf = d.values[0].Conf_Clean;
                    } else {
                        conf = d.conf;
                    }

                    if(conf == 'Big Ten') {
                        conf = 'Big_Ten';
                    } else if(conf == 'Big 12') {
                        conf = 'Big_12';
                    }

                    // first every group turns grey
                    d3.selectAll("path.change")
                        .transition().duration(200)
                        .attr("opacity", ".05");

                    d3.selectAll("circle.change")
                        .transition().duration(200)
                        .attr("opacity", ".05");

                    // Second the hovered specie takes its color
                    d3.selectAll("path." + conf)
                        .transition().duration(200)
                        .attr("opacity", "1");
                        // .attr("stroke", "black")
                        // .attr("stroke-width", "2px");
                    d3.selectAll("circle." + conf)
                        .transition().duration(200)
                        .attr("opacity", "1");
                    
                }

                // Unhighlight
                var doNotHighlight = function() {
                    d3.selectAll("path")
                        .transition().duration(200)
                        .attr("opacity", "1");
                        // .attr("stroke", "none");
                    d3.selectAll("circle")
                        .transition().duration(200)
                        .attr("opacity", "1");
                }

                let confs = [
                    {conf: 'ACC', color: '#013ca6'}, 
                    {conf: 'Big 12', color: '#ef483e'}, 
                    {conf: 'Big Ten', color: '#0088CE'},
                    {conf: 'SEC', color: '#ffd046'},
                    {conf: 'Pac12', color: '#04223f'},
                    {conf: 'Other', color: '#808080'}];

                data.forEach((d) =>{
                    if(d.Conf_Clean == 'ACC') {
                        d.color = '#013ca6';
                    } else if (d.Conf_Clean == 'Big 12') {
                        d.color = '#ef483e'
                    } else if (d.Conf_Clean == 'Big Ten') {
                        d.color = '#0088CE';
                    } else if (d.Conf_Clean == 'Other') {
                        d.color = '#808080';
                    } else if (d.Conf_Clean == 'Pac12') {
                        d.color = '#04223f';
                    } else if (d.Conf_Clean == 'SEC') {
                        d.color = '#ffd046';
                    }
                });

                let First_AP = document.getElementById("First_AP").value;
                let Second_AP = document.getElementById("Second_AP").value;
                let Pro_Bowl = document.getElementById("Pro_Bowl").value;

                data.forEach((d) => {
                    d.score = (First_AP * d.First_AP) + (Second_AP * d.Second_AP) + (Pro_Bowl * d.Pro_Bowl);
                })


                var groups = d3.nest()
                    .key(function(d) {return d.Conf_Clean;})
                    .entries(data);

                var svg = d3.select("#svg-weighted-lines")
                    .append("svg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                        .attr("transform",
                            "translate(" + margin.left + "," + margin.top + ")");

                

                // Add X axis --> it is a date format
                var x = d3.scaleTime()
                    .domain([new Date('2010'), new Date('2020/01')])
                    .range([ 0, width ]);
                svg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x).ticks(5).tickSize(0).tickPadding(15));

                // Add Y axis
                var y = d3.scaleLinear()
                    .domain([0, d3.max(data, function(d) { return +d.score; })])
                    .range([ height, 0 ]);
                svg.append("g")
                    .call(d3.axisLeft(y).ticks(4).tickSize(0).tickPadding(15));

                // Draw the line
                svg.selectAll(".line")
                    .data(groups)
                    .enter()
                    .append("path")
                        .attr('class', (d) => {
                            if(d.values[0].Conf_Clean == 'Big Ten') {
                                return 'change Big_Ten';
                            } else if(d.values[0].Conf_Clean == 'Big 12') {
                                return 'change Big_12';
                            } else {
                                return 'change ' + d.values[0].Conf_Clean;
                            }
                        })
                        .attr("fill", "none")
                        .attr("stroke", function(d){ return d.values[0].color })
                        .attr("stroke-width", 1.5)
                        .attr("d", function(d){
                        return d3.line()
                            .x(function(d) { return x(new Date(d.Year)); })
                            .y(function(d) { return y(+d.score); })
                            (d.values)
                        })
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight);

                svg.append("text")
                    .attr("x", width/2)
                    .attr("y", -5)
                    .attr("text-anchor", "middle")
                    .style("font-family", "helvetica")
                    .style("font-size", "12px")
                    .text("Weighted Scores");

                // make legend 
                svg.selectAll('.legend-circle')
                    .data(confs)
                    .enter()
                        .append('circle')
                        .attr("class", (d) => {
                            if(d.conf == 'Big Ten') {
                                return 'legend-circle change Big_Ten';
                            } else if(d.conf == 'Big 12') {
                                return 'legend-circle change Big_12';
                            } else {
                                return 'legend-circle change ' + d.conf;
                            }
                        })
                        .attr('r', 5)
                        .attr('cx', width + 20)
                        .attr('cy', function (d, i) {
                            return 10 + (20 * i);
                        })
                        .style('fill', function (d) {
                            return d.color;
                        })
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight);

                svg.selectAll('.legend-text')
                    .data(confs)
                    .enter()
                        .append("text")
                        .attr('class', 'legend-text')
                        .attr("x", width + 40)
                        .attr("y", function (d, i) {
                            return 10 + (20 * i);
                        })
                        .text(function(d) {
                            return d.conf;
                        })
                        .style("font-size", "16px")
                        .style("font-family", "Helvetica")
                        .attr("alignment-baseline","middle")
                        .attr('fill', 'black')
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight);
            });

        }

        function makeSECBubble() {

            let title_map = {
                'MVP': 'MVP',
                'SB_MVP': 'Super Bowl MVP',
                'SB_WIN': 'Super Bowl Win',
                'OPOY': 'OPOY',
                'OROY': 'OROY',
                'DPOY': 'DROY',
                'DROY': 'DROY',
                'Pro_Bowl': 'Pro Bowl',
                'First_AP': 'First Team All Pro',
                'Second_AP': 'Second Team All Pro'
            }

            function sumValue(group) {
                return d3.sum(group, function(d) {
                    return d["value"];
                });
            }

            childrenAccess = ([key, value]) => value.size && Array.from(value)

            const margin = {top: 0, right: 200, bottom: 0, left: 50};
                const width = 1000 - margin.left - margin.right;
                const height = 750 - margin.top - margin.bottom;

            d3.csv("python/results/total/sec_bubble.csv", function(data) {

                let accolades = ["First_AP", "Second_AP", "Pro_Bowl", "MVP", "SB_MVP", "SB_WIN", "OPOY", "DPOY", "OROY", "DROY"];

                let color = d3.scaleOrdinal().domain(accolades).range(d3.schemeTableau10);

                // Highlight the specie that is hovered
                var highlight = function(d){

                    let acc
                    
                    if(d.data) {
                        acc = d.data[0];
                    } else {
                        acc = d;
                    }
                    
                    if(accolades.includes(acc)) {
                        // first every group turns grey
                        d3.selectAll("circle.change")
                            .transition().duration(200)
                            .attr("opacity", ".05");

                        d3.selectAll("text.change")
                            .transition().duration(200)
                            .attr("opacity", ".05");

                        // Second the hovered specie takes its color
                        d3.selectAll("circle." + acc)
                            .transition().duration(200)
                            .attr("opacity", "1");
                            // .attr("stroke", "black")
                            // .attr("stroke-width", "2px");
                        d3.selectAll("text." + acc)
                            .transition().duration(200)
                            .attr("opacity", "1");
                    }
                }

                // Unhighlight
                var doNotHighlight = function() {
                    d3.selectAll("circle")
                        .transition().duration(200)
                        .attr("opacity", "1");
                        // .attr("stroke", "none");
                    d3.selectAll("text")
                        .transition().duration(200)
                        .attr("opacity", "1");
                }

                data.forEach(d => {
                    if(d.Pos == 'OLB' || d.Pos == 'ILB') {
                        d.Pos = 'LB';
                    } else if (d.Pos == 'SS' || d.Pos == 'FS') {
                        d.Pos = 'S';
                    } else if (d.Pos == 'OT' || d.Pos == 'OG' || d.Pos == 'G' || d.Pos == 'NT' || d.Pos == 'C') {
                        d.Pos = 'OL';
                    }
                });

                data = data.filter(d => { return (d.Pos != 'LS' && d.Pos != 'P');});

                let groups = d3.rollup(data, 
                                    sumValue,
                                    function(d) { return d.Pos; },
                                    function(d) { return d.Accolade; }
                                );

                let root = d3.hierarchy([null, groups], childrenAccess)
                    .sum(([,value]) => value)
                    .sort((a, b) => b.value - a.value);

                let packed = d3.pack()
                    .size([width, height])
                    .padding(5);

                packed(root);
                
                var svg = d3.select("#svg-sec-bubble")
                    .append("svg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                        .attr("transform",
                            "translate(" + margin.left + "," + margin.top + ")");

                svg.selectAll('circle')
                    // slice(1) skips the root node
                    .data(root.descendants())
                    .enter()
                    .append('circle')
                        .attr('class', (d) => {
                            if(d.depth == 2) {
                                return "change " + d.data[0];
                            } else {
                                return 'no-change';
                            }
                        })
                        .attr('r', (d) => {
                            return d.r;
                        })
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y)
                        .attr('stroke', 'none')
                        .attr('stroke-width', 2)
                        .attr('fill', (d) => {
                            if(d.depth == 2) {
                                return color(d.data[0]);
                            } else if(d.depth == 1) {
                                return '#C1C1C1';
                            } else {
                                return '#D3D3D3';
                            }
                        })
                        .attr('opacity', '1')
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight);

                svg.selectAll('text')
                    .data(root.descendants())
                    .enter()
                    .append('text')
                        .attr('class', (d) => {
                            if(d.depth == 2) {
                                return 'change ' + d.data[0];
                            } else {
                                return 'no-change';
                            }
                        })
                        .attr('x', d => d.x - 5)
                        .attr('y', (d) => {
                            if(d.depth == 2) {
                                return d.y + 2;
                            } else {
                                return d.y - d.r - 2;
                            }
                        })
                        .text((d) => {
                            if(d.depth == 2) {
                                if(d.data[1] != 0) {
                                    return d.data[1];
                                }
                            } else {
                                return d.data[0];
                            }
                        })
                        .attr('font-family', 'helvetica')
                        .attr('font-size', (d) => {
                            if(d.depth == 2) {
                                return '12px';
                            } else {
                                return '16px';
                            }
                        })
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight);

                // make legend 
                svg.selectAll('.legend-circle')
                    .data(accolades)
                    .enter()
                        .append('circle')
                        .attr("class", (d) => {
                            return 'legend-circle change ' + d;
                        })
                        .attr('r', 8)
                        .attr('cx', width + 20)
                        .attr('cy', function (d, i) {
                            return 200 + (30 * i);
                        })
                        .style('fill', function (d) {
                            return color(d);
                        })
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight);

                svg.selectAll('.legend-text')
                    .data(accolades)
                    .enter()
                        .append("text")
                        .attr('class', 'legend-text')
                        .attr("x", width + 40)
                        .attr("y", function (d, i) {
                            return 200 + (30 * i);
                        })
                        .text(function (d) {
                            return title_map[d];
                        })
                        .style("font-size", "16px")
                        .style("font-family", "Helvetica")
                        .attr("alignment-baseline","middle")
                        .on("mouseover", highlight)
                        .on("mouseleave", doNotHighlight);

            });
        }


        // makePosPCP();
        // makeConfPCP();
        // makeConfBars();
        makeSmallMultiples();
        makeLines();
        makeWeightedLines();
        makeSECBubble();

    </script>

</html>